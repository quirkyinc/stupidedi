# encoding: UTF-8
require "spec_helper"

describe Stupidedi::Sets::AbsoluteSet do
  include QuickCheck::Macro

  def mksubset(universe)
    universe.copy(:mask => rand(2**universe.size))
  end

  def mksingleton(universe)
    universe.copy(:mask => (2**(rand(universe.size) + 1) >> 1))
  end

  let(:items) { %w(a b c d e f g h i j k l m n o p q r s t u v w x y z) }

  let(:universe) { Stupidedi::Sets.absolute(items) }
  let(:single)   { universe.copy(:mask => 0b00000000000000000000000001) }
  let(:subset)   { universe.copy(:mask => 0b10101010101010101010101010) }
  let(:null)     { universe.copy(:mask => 0b00000000000000000000000000) }

  describe "#to_a" do
    specify "|A| == |A.to_a|" do
      null.size.should == null.to_a.size
      single.size.should == single.to_a.size
      subset.size.should == subset.to_a.size
      universe.size.should == universe.to_a.size
    end

    property("if x ∉ A then x ∉ A.to_a") do
      a = mksubset(universe)
      [a, a.to_a]
    end.check do |a, to_a|
      universe.each do |x|
        unless a.include?(x)
          to_a.should_not include(x)
        end
      end
    end

    property("if x ∈ A then x ∈ A.to_a") do
      a = mksubset(universe)
      [a, a.to_a]
    end.check do |a, to_a|
      universe.each do |x|
        if a.include?(x)
          to_a.should include(x)
        end
      end
    end
  end

  describe "#first" do
    property("{x}.first = x") do
      x = choose(universe.to_a)
      a = universe & [x]
      [a, x]
    end.check do |a, x|
      a.first.should == x
    end

    property("A.first ∈ A") do
      mksubset(universe)
    end.check do |a|
      a.should include(a.first)
    end
  end

  describe "#map(&block)" do
    specify "A.map{|a| a } = A" do
      null.map{|a| a }.should == null
      single.map{|a| a }.should == single
      subset.map{|a| a }.should == subset
      universe.map{|a| a }.should == universe
    end

    property("A.map{|a| a } = A") do
      mksubset(universe)
    end.check do |subset|
      subset.map{|a| a }.should == subset
    end

    specify "A.map{|a| b } raises an error, given b ∉ U and A ≠ ∅" do
      lambda { single.map{|a| "A" }}.should \
        raise_error(/universe does not contain element/)

      lambda { subset.map{|a| "A" }}.should \
        raise_error(/universe does not contain element/)

      lambda { universe.map{|a| "A" }}.should \
        raise_error(/universe does not contain element/)
    end

    specify "A.map{|a| b } = {b}, given b ∈ U, A ≠ ∅" do
      single.map{|a| "a" }.should == %w(a)
      subset.map{|a| subset.first }.should == [subset.first]
      universe.map{|a| "z" }.should == %w(z)
    end

    property("A.map{|a| b } = {b}, given b ∈ U, A ≠ ∅") do
      [mksubset(universe), choose(universe.to_a)]
    end.check do |subset, e|
      subset.map{|a| e }.should == [e]
    end
  end

  describe "#select(&block)" do
    specify "A.select{|a| true } = A" do
      null.select{|a| true }.should == null
      single.select{|a| true }.should == single
      subset.select{|a| true }.should == subset
      universe.select{|a| true }.should == universe
    end

    property("A.select{|a| true } = A") do
      mksubset(universe)
    end.check do |subset|
      subset.select{|a| true }.should == subset
    end

    specify "A.select{|a| false } = ∅" do
      null.select{|a| false }.should == null
      single.select{|a| false }.should == null
      subset.select{|a| false }.should == null
      universe.select{|a| false }.should == null
    end

    property("A.select{|a| false } = ∅") do
      mksubset(universe)
    end.check do |subset|
      subset.select{|a| false }.should == null
    end

    specify "A.select{|a| a == b } = {b}, given b ∈ U, A ≠ ∅" do
      single.select{|a| a == "a" }.should == %w(a)
      subset.select{|a| a == subset.first }.should == [subset.first]
      universe.select{|a| a == "a" }.should == %w(a)
    end

    property("A.select{|a| a == b } = {b}, given b ∈ U, A ≠ ∅") do
      subset  = mksubset(universe)
      element = choose(subset.to_a)
      [subset, element]
    end.check do |subset, e|
      subset.select{|a| a == e }.should == [e]
    end
  end

  describe "#reject(&block)" do
    specify "A.reject{|a| false } = A" do
      null.reject{|a| false }.should == null
      single.reject{|a| false }.should == single
      subset.reject{|a| false }.should == subset
      universe.reject{|a| false }.should == universe
    end

    property("A.reject{|a| false } = A") do
      mksubset(universe)
    end.check do |subset|
      subset.reject{|a| false }.should == subset
    end

    specify "A.reject{|a| true } = ∅" do
      null.reject{|a| true }.should == null
      single.reject{|a| true }.should == null
      subset.reject{|a| true }.should == null
      universe.reject{|a| true }.should == null
    end

    property("A.reject{|a| true } = ∅") do
      mksubset(universe)
    end.check do |subset|
      subset.reject{|a| true }.should == null
    end

    specify "A.reject{|a| a != b } = {b}, given b ∈ U, A ≠ ∅" do
      single.reject{|a| a != "a" }.should == %w(a)
      subset.reject{|a| a != subset.first }.should == [subset.first]
      universe.reject{|a| a != "a" }.should == %w(a)
    end

    property("A.reject{|a| a != b } = {b}, given b ∈ U, A ≠ ∅") do
      subset  = mksubset(universe)
      element = choose(subset.to_a)
      [subset, element]
    end.check do |subset, e|
      subset.reject{|a| a != e }.should == [e]
    end
  end

  describe "#include?(element)" do
    specify "x ∉ ∅, for all x" do
      null.should_not include("a")
      null.should_not include("A")
    end

    specify "x ∉ A, for all x ∉ U" do
      single.should_not include("A")
      subset.should_not include("A")
      universe.should_not include("A")
    end

    specify "x ∈ {x}, for all x" do
      single.should include("a")
    end

    property("x ∈ {x}, for all x") do
      mksingleton(universe)
    end.check do |singleton|
      singleton.should include(singleton.first)
    end

    property("x ∉ A, for all x ∈ ¬A") do
      mksubset(universe)
    end.check do |a|
      (~a).each{|e| a.should_not include(e) }
    end
  end

  describe "#finite?" do
    it "is true" do
      null.should be_finite
      single.should be_finite
      subset.should be_finite
      universe.should be_finite
    end
  end

  describe "#empty?" do
    specify "∅.empty? is true" do
      null.should be_empty
    end

    specify "{x}.empty? is false" do
      single.should_not be_empty
    end
  end

  describe "#size" do
    specify "∅.size == 0" do
      null.size == 0
    end

    specify "{x}.size == 1" do
      single.size.should == 1
    end
  end

  describe "#complement" do
    specify "A ∩ ¬A = ∅" do
      (null & ~null).should == null
      (single & ~single).should == null
      (subset & ~subset).should == null
      (universe & ~universe).should == null
    end

    property("A ∩ ¬A = ∅") do
      mksubset(universe)
    end.check do |a|
      (a & ~a).should == null
    end

    specify "A ∪ ¬A = U" do
      (null | ~null).should == universe
      (single | ~single).should == universe
      (subset | ~subset).should == universe
      (universe | ~universe).should == universe
    end

    property("A ∪ ¬A = U") do
      mksubset(universe)
    end.check do |a|
      (a | ~a).should == universe
    end

    specify "A ⊖ ¬A = U" do
      (null ^ ~null).should == universe
      (single ^ ~single).should == universe
      (subset ^ ~subset).should == universe
      (universe ^ ~universe).should == universe
    end

    property("A ⊖ ¬A = U") do
      mksubset(universe)
    end.check do |a|
      (a ^ ~a).should == universe
    end

    specify "A ∖ ¬A = A" do
      (null - ~null).should == null
      (single - ~single).should == single
      (subset - ~subset).should == subset
      (universe - ~universe).should == universe
    end

    property("A ∖ ¬A = A") do
      mksubset(universe)
    end.check do |a|
      (a - ~a).should == a
    end

    specify "x ∉ ¬A, for all x ∉ U" do
      (~null).should_not include("A")
      (~single).should_not include("A")
      (~subset).should_not include("A")
      (~universe).should_not include("A")
    end

    property("x ∈ ¬A, for all x ∈ U and x ∉ A") do
      mksubset(universe)
    end.check do |a|
      (~a).each{|e| a.should_not include(e) }
    end

    property("x ∉ ¬A, for all x ∈ U and x ∈ A") do
      mksubset(universe)
    end.check do |a|
      a.each{|e| (~a).should_not include(e) }
    end

    specify "¬U = ∅" do
      (~universe).should == null
    end

    specify "¬∅ = U" do
      (~null).should == universe
    end

    # Identity
    specify "¬(¬A) = A" do
      (~(~null)).should == null
      (~(~single)).should == single
      (~(~subset)).should == subset
      (~(~universe)).should == universe
    end

    property("¬(¬A) = A") do
      mksubset(universe)
    end.check do |a|
      (~(~a)).should == a
    end

    # De Morgan's Laws
    property("¬(A ∪ B) = ¬A ∩ ¬B") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (~(a | b)).should == (~a & ~b)
    end

    property("¬(A ∩ B) = ¬A ∪ ¬B") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (~(a & b)).should == (~a | ~b)
    end

    # Uniqueness of Complements
    property("B = ¬A, given A ∪ B = U and A ∩ B = ∅") do
      # Create a smaller universe, because the chances of choosing
      # two random subsets from 2**26 possible, that happen to be
      # disjoint is very small.
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)

      guard(a | b == universe)
      guard(a & b == null)

      [a, b]
    end.check(2, 500) do |a, b|
      b.should == ~a
    end
  end

  describe "#union(other)" do
    property("x ∈ A ∪ B, for all x ∈ A") do
      a = mksubset(universe)
      b = mksubset(universe)
      [a, b, (a | b)]
    end.check do |a, b, union|
      a.each{|x| union.should include(x) }
    end

    property("x ∈ A ∪ B, for all x ∈ B") do
      a = mksubset(universe)
      b = mksubset(universe)
      [a, b, (a | b)]
    end.check do |a, b, union|
      b.each{|x| union.should include(x) }
    end

    property("x ∉ A ∪ B, for all x ∉ A and x ∉ B") do
      a = mksubset(universe)
      b = mksubset(universe)
      [a, b, (a | b)]
    end.check do |a, b, union|
      universe.each do |x|
        unless a.include?(x) or b.include?(x)
          union.should_not include(x)
        end
      end
    end

    property("A ∪ B = A, given B ⊂ A") do
      # Create a smaller universe, because the chances of choosing
      # two random subsets from 2**26 possible, that happen to be
      # subsets of each other is very small.
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)
      guard(b < a)

      [a, b]
    end.check do |a, b|
      (a | b).should == a
    end

    property("A ∪ B = B, given B ⊃ A") do
      # Create a smaller universe, because the chances of choosing
      # two random subsets from 2**26 possible, that happen to be
      # subsets of each other is very small.
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)
      guard(b > a)

      [a, b]
    end.check do |a, b|
      (a | b).should == b
    end

    property("A ∪ B ⊇ A") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a | b).should >= a
    end

    property("A ∪ B ⊇ B") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a | b).should >= b
    end

    property("A ∪ B ⊃ A, given A ∩ B = ∅") do
      # Create a smaller universe, because the chances of choosing
      # two random subsets from 2**26 possible, that happen to be
      # disjoint is very small.
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)
      guard(b & a == null)

      [a, b]
    end.check do |a, b|
      (a | b) > a
    end

    # Absorption
    property("A ∪ (A ∩ B) = A") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a | (a & b)).should == a
    end

    # Idempotent
    specify "A ∪ A = A" do
      (null + null).should == null
      (single + single).should == single
      (subset + subset).should == subset
      (universe + universe).should == universe
    end

    # Domination
    specify "A ∪ U = U" do
      (null + universe).should == universe
      (single + universe).should == universe
      (subset + universe).should == universe
      (universe + universe).should == universe
    end

    # Complement
    specify "A ∪ ¬A = U" do
      (null | ~null).should == universe
      (single | ~single).should == universe
      (subset | ~subset).should == universe
      (universe | ~universe).should == universe
    end

    # Identity
    specify "A ∪ ∅ = A" do
      (null + null).should == null
      (single + null).should == single
      (subset + null).should == subset
      (universe + null).should == universe
    end

    # Distributive
    property("A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      (a | (b & c)).should == ((a | b) & (a | c))
    end

    # Commutative
    property("A ∪ B = B ∪ A") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a | b).should == (b | a)
    end

    # Associative
    property("(A ∪ B) ∪ C = A ∪ (B ∪ C)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      ((a | b) | c).should == (a | (b | c))
    end

    context "if B is a RelativeSet" do
      context "and B ⊆ U" do
        property("then A ∪ B = A ∪ Sets.absolute(B, U)") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, b|
          r = Stupidedi::Sets.build(b.to_a)

          (a | b).should == (a | r)
          (a | r).should == (a | b)
          (a | r).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end

      context "and B ⊈ U" do
        property("then A ∪ B raises an error") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))
          [a, b]
        end.check do |a, b|
          r = Stupidedi::Sets.build(b.to_a)

          lambda { a | r }.should \
            raise_error
        end
      end
    end

    context "if B is a RelativeComplement" do
      context "and ¬B ⊆ U" do
        property("then A ∪ B = B ∪ A") do
          a = mksubset(universe)
          b = mksubset(universe)

          [a, Stupidedi::Sets.complement(b.to_a)]
        end.check do |a, b|
          (a | b).should == b | a
          (a | b).should be_a(Stupidedi::Sets::RelativeComplement)
        end
      end

      context "and ¬B ⊈ U" do
        property("then A ∪ B = B ∪ A") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))

          [a, Stupidedi::Sets.complement(b.to_a)]
        end.check do |a, b|
          (a | b).should == b | a
          (a | b).should be_a(Stupidedi::Sets::RelativeComplement)
        end
      end
    end

    context "if B is an Array" do
      context "and B ⊆ U" do
        property("then A ∪ B = A ∪ Sets.absolute(B, U)") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, b|
          r = b.to_a

          (a | b).should == (a | r)
          (a | r).should == (a | b)
          (a | r).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end

      context "and B ⊈ U" do
        property("then A ∪ B raises an error") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))
          [a, b]
        end.check do |a, b|
          r = b.to_a

          lambda { a | r }.should \
            raise_error(/invalid character/)
        end
      end
    end
  end

  describe "#intersection(other)" do
    property("x ∈ A ∩ B, for all x ∈ A and x ∈ B") do
      a = mksubset(universe)
      b = mksubset(universe)
      [a, b, (a & b)]
    end.check do |a, b, intersection|
      a.each do |x|
        if b.include?(x)
          intersection.should include(x)
        end
      end
    end

    property("x ∉ A ∩ B, for all x ∉ A") do
      a = mksubset(universe)
      b = mksubset(universe)
      [a, b, (a & b)]
    end.check do |a, b, intersection|
      universe.each do |x|
        unless a.include?(x)
          intersection.should_not include(x)
        end
      end
    end

    property("x ∉ A ∩ B, for all x ∉ B") do
      a = mksubset(universe)
      b = mksubset(universe)
      [a, b, (a & b)]
    end.check do |a, b, intersection|
      universe.each do |x|
        unless b.include?(x)
          intersection.should_not include(x)
        end
      end
    end

    specify "A ∩ U = A" do
      (null & universe).should == null
      (single & universe).should == single
      (subset & universe).should == subset
      (universe & universe).should == universe
    end

    property("A ∩ B = A, given B ⊇ A") do
      # Create a smaller universe, because the chances of choosing
      # two random subsets from 2**26 possible, that happen to be
      # subsets of each other is very small.
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)
      guard(b >= a)

      [a, b]
    end.check do |a, b|
      (a & b).should == a
    end

    property("A ∩ B = B, given B ⊆ A") do
      # Create a smaller universe, because the chances of choosing
      # two random subsets from 2**26 possible, that happen to be
      # subsets of each other is very small.
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)
      guard(b <= a)

      [a, b]
    end.check do |a, b|
      (a & b).should == b
    end

    # Absorption
    property("A ∩ (A ∪ B) = A") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a & (a | b)).should == a
    end

    # Idempotent
    specify "A ∩ A = A" do
      (null & null).should == null
      (single & single).should == single
      (subset & subset).should == subset
      (universe & universe).should == universe
    end

    # Domination
    specify "A ∩ ∅ = ∅" do
      (null & null).should == null
      (single & null).should == null
      (subset & null).should == null
      (universe & null).should == null
    end

    # Complement
    specify "A ∩ ¬A = ∅" do
      (null & ~null).should == null
      (single & ~single).should == null
      (subset & ~subset).should == null
      (universe & ~universe).should == null
    end

    # Distributive
    property("A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      (a & (b | c)).should == ((a & b) | (a & c))
    end

    # Commutative
    property("A ∩ B = B ∩ A") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a & b).should == (b & a)
    end

    # Associative
    property("(A ∩ B) ∩ C = A ∩ (B ∩ C)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      ((a & b) & c).should == (a & (b & c))
    end

    context "if B is a RelativeSet" do
      context "and B ⊆ U" do
        property("then A ∩ B = A ∩ Sets.absolute(B, U)") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, b|
          r = Stupidedi::Sets.build(b.to_a)

          (a & b).should == (a & r)
          (a & r).should == (a & b)
          (a & r).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end

      context "and B ⊈ U" do
        property("then A ∩ B = A ∩ Sets.absolute(B ∩ U, U)") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))
          [a, b]
        end.check do |a, b|
          r = Stupidedi::Sets.build(b.to_a)       # B
          b = universe.select{|x| b.include?(x) } # B ∩ U

          (a & b).should == (a & r)
          (a & r).should == (a & b)
          (a & r).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end
    end

    context "if B is a RelativeComplement" do
      context "and ¬B ⊆ U" do
        property("then A ∩ B = B ∩ A") do
          a = mksubset(universe)
          b = mksubset(universe)

          [a, Stupidedi::Sets.complement(b.to_a)]
        end.check do |a, b|
          (a & b).should == b & a
          (a & b).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end

      context "and ¬B ⊈ U" do
        property("then A ∩ B = B ∩ A") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))

          [a, Stupidedi::Sets.complement(b.to_a)]
        end.check do |a, b|
          (a & b).should == b & a
          (a & b).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end
    end

    context "if B is an Array" do
      context "and B ⊆ U" do
        property("then A ∩ B = A ∩ Sets.absolute(B, U)") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, b|
          r = b.to_a

          (a & b).should == (a & r)
          (a & r).should == (a & b)
          (a & r).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end

      context "and B ⊈ U" do
        property("then A ∩ B = A ∩ Sets.absolute(B ∩ U, U)") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))
          [a, b]
        end.check do |a, b|
          r = b.to_a                              # B
          b = universe.select{|x| b.include?(x) } # B ∩ U

          (a & b).should == (a & r)
          (a & r).should == (a & b)
          (a & r).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end
    end
  end

  describe "#difference(other)" do
    property("x ∈ A ∖ B, for all x ∈ A and x ∉ B") do
      a = mksubset(universe)
      b = mksubset(universe)
      [a, b, (a - b)]
    end.check do |a, b, difference|
      a.each do |x|
        unless b.include?(x)
          difference.should include(x)
        end
      end
    end

    property("x ∉ A ∖ B, for all x ∉ A") do
      a = mksubset(universe)
      b = mksubset(universe)
      [a, b, (a - b)]
    end.check do |a, b, difference|
      universe.each do |x|
        unless a.include?(x)
          difference.should_not include(x)
        end
      end
    end

    property("x ∉ A ∖ B, for all x ∈ B") do
      a = mksubset(universe)
      b = mksubset(universe)
      [a, b, (a - b)]
    end.check do |a, b, difference|
      b.each do |x|
        difference.include?(x).should be_false
      end
    end

    specify "U ∖ A = ¬A" do
      (universe - null).should == ~null
      (universe - single).should == ~single
      (universe - subset).should == ~subset
      (universe - universe).should == ~universe
    end

    specify "∅ ∖ A = ∅" do
      (null - null).should == null
      (null - single).should == null
      (null - subset).should == null
      (null - universe).should == null
    end

    specify "A ∖ A = ∅" do
      (null - null).should == null
      (single - single).should == null
      (subset - subset).should == null
      (universe - universe).should == null
    end

    specify "A ∖ ∅ = A" do
      (null - null).should == null
      (single - null).should == single
      (subset - null).should == subset
      (universe - null).should == universe
    end

    specify "A ∖ U = ∅" do
      (null - universe).should == null
      (single - universe).should == null
      (subset - universe).should == null
      (universe - universe).should == null
    end

    property("A ∖ B = A, given A ∩ B = ∅")

    property("A ∖ B ⊂ A, given A ∩ B ≠ ∅") do
      a = mksubset(universe)
      b = mksubset(universe)
      guard(a & b != null)

      [a, b]
    end.check do |a, b|
      (a - b).should < a
    end

    property("A ∖ B ≠ B ∖ A, given A ≠ B") do
      a = mksubset(universe)
      b = mksubset(universe)
      guard(a != b)

      [a, b]
    end.check do |a, b|
      (a - b).should_not == (b - a)
    end

    property("C ∖ (A ∩ B) = (C ∖ A) ∪ (C ∖ B)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      (c - (a & b)).should == ((c - a) | (c - b))
    end

    property("C ∖ (A ∪ B) = (C ∖ A) ∩ (C ∖ B)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      (c - (a | b)).should == ((c - a) & (c - b))
    end

    property("C ∖ (B ∖ A) = (A ∩ C) ∪ (C ∖ B)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      (c - (b - a)).should == ((a & c) | (c - b))
    end

  # property("(B ∖ A) ∩ C = (B ∩ C) ∖ A = B ∩ (C ∖ A)") do
  #   [mksubset(universe), mksubset(universe), mksubset(universe)]
  # end.check do |a, b, c|
  # end

    property("(B ∖ A) ∪ C = (B ∪ C) ∖ (A ∖ C)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      ((b - a) | c).should == ((b | c) - (a - c))
    end

    property("B ∖ A = ¬A ∩ B") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (b - a).should == (~a & b)
    end

    property("¬(B ∖ A) = A ∪ ¬B") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (~(b - a)).should == (a | ~b)
    end

    context "if B is a RelativeSet" do
      context "and B ⊆ U" do
        property("then A ∖ B = A ∖ Sets.absolute(B, U)") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, b|
          r = Stupidedi::Sets.build(b.to_a)

          (a - b).should == (a - r)
          (a - r).should == (a - b)
          (a - r).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end

      context "and B ⊈ U" do
        property("then A ∖ B = A ∖ Sets.absolute(B ∩ U, U)") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))
          [a, b]
        end.check do |a, b|
          r = Stupidedi::Sets.build(b.to_a)       # B
          b = universe.select{|x| b.include?(x) } # B ∩ U

          (a - b).should == (a - r)
          (a - r).should == (a - b)
          (a - r).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end
    end

    context "if B is a RelativeComplement" do
      context "and ¬B ⊆ U" do
        property("then A ∖ B = A ∩ ¬B") do
          a = mksubset(universe)
          b = mksubset(universe)

          [a, Stupidedi::Sets.complement(b.to_a)]
        end.check do |a, b|
          (a - b).should == (a & ~b)
          (a - b).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end

      context "and ¬B ⊈ U" do
        property("then A ∖ B = A ∩ ¬B") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))

          [a, Stupidedi::Sets.complement(b.to_a)]
        end.check do |a, b|
          (a - b).should == (a & ~b)
          (a - b).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end
    end

    context "if B is an Array" do
      context "and B ⊆ U" do
        property("then A ∖ B = A ∖ Sets.absolute(B, U)") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, b|
          r = b.to_a

          (a - b).should == (a - r)
          (a - r).should == (a - b)
          (a - r).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end

      context "and B ⊈ U" do
        property("then A ∖ B = A ∖ Sets.absolute(B ∩ U, U)") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))
          [a, b]
        end.check do |a, b|
          r = b.to_a                              # B
          b = universe.select{|x| b.include?(x) } # B ∩ U

          (a - b).should == (a - r)
          (a - r).should == (a - b)
          (a - r).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end
    end
  end

  describe "#symmetric_difference(other)" do
    specify "A ⊖ A = ∅" do
      (null ^ null).should == null
      (single ^ single).should == null
      (subset ^ subset).should == null
      (universe ^ universe).should == null
    end

    specify "A ⊖ U = ¬A" do
      (null ^ universe).should == ~null
      (single ^ universe).should == ~single
      (subset ^ universe).should == ~subset
      (universe ^ universe).should == ~universe
    end

    specify "A ⊖ ∅ = A" do
      (null ^ null).should == null
      (single ^ null).should == single
      (subset ^ null).should == subset
      (universe ^ null).should == universe
    end

    property("A ⊖ B = (A ∖ B) ∪ (B ∖ A)") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a ^ b).should == ((a - b) | (b - a))
    end

    property("A ⊖ B = (A ∪ B) ∖ (A ∩ B)") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a ^ b).should == ((a | b) - (a & b))
    end

    property("A ⊖ B = B ⊖ A") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      (a ^ b).should == (b ^ a)
    end

    property("(A ⊖ B) ⊖ C = A ⊖ (B ⊖ C)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      ((a ^ b) ^ c).should == (a ^ (b ^ c))
    end

    property("(A ⊖ B) ⊖ (B ⊖ C) = A ⊖ C") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      ((a ^ b) ^ (b ^ c)).should == (a ^ c)
    end

    property("A ∩ (B ⊖ C) = (A ∩ B) ⊖ (A ∩ C)") do
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      (a & (b ^ c)).should == ((a & b) ^ (a & c))
    end

    context "if B is a RelativeSet" do
      context "and B ⊆ U" do
        property("then A ⊖ B = A ⊖ Sets.absolute(B, U)") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, b|
          r = Stupidedi::Sets.build(b.to_a)

          (a ^ b).should == (a ^ r)
          (a ^ r).should == (a ^ b)
          (a ^ r).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end

      context "and B ⊈ U" do
        property("then A ⊖ B raises an error") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))
          [a, b]
        end.check do |a, b|
          r = Stupidedi::Sets.build(b.to_a)

          lambda { a ^ r }.should \
            raise_error
        end
      end
    end

    context "if B is a RelativeComplement" do
      context "and ¬B ⊆ U" do
        property("then A ⊖ B = B ⊖ A") do
          a = mksubset(universe)
          b = mksubset(universe)

          [a, Stupidedi::Sets.complement(b.to_a)]
        end.check do |a, b|
          (a ^ b).should == b ^ a
          (a ^ b).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end

      context "and ¬B ⊈ U" do
        property("then A ⊖ B = B ⊖ A") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))

          [a, Stupidedi::Sets.complement(b.to_a)]
        end.check do |a, b|
          (a ^ b).should == b ^ a
          (a ^ b).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end
    end

    context "if B is an Array" do
      context "and B ⊆ U" do
        property("then A ⊖ B = A ⊖ Sets.absolute(B, U)") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, b|
          r = b.to_a

          (a ^ b).should == (a ^ r)
          (a ^ r).should == (a ^ b)
          (a ^ r).should be_a(Stupidedi::Sets::AbsoluteSet)
        end
      end

      context "and B ⊈ U" do
        property("then A ⊖ B raises an error") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))
          [a, b]
        end.check do |a, b|
          r = b.to_a

          lambda { a ^ r }.should \
            raise_error(/invalid character/)
        end
      end
    end
  end

  describe "#subset?(other)" do
    # Reflexivity
    specify "A ⊆ A" do
      null.should <= null
      single.should <= single
      subset.should <= subset
      universe.should <= universe
    end

    # Antisymmetry
    property("A ⊆ B and B ⊆ A, given A = B") do
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)
      guard(a == b)

      [a, b]
    end.check(5, 200) do |a, b|
      a.should <= b
      b.should <= a
    end

    property("A = B, given A ⊆ B and B ⊆ A") do
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)
      guard(a <= b)
      guard(b <= a)

      [a, b]
    end.check(5, 200) do |a, b|
      a.should == b
    end

    # Transitivity
    property("A ⊆ C, given A ⊆ B and B ⊆ C") do
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)
      c = mksubset(universe)
      guard(a <= b)
      guard(b <= c)

      [a, b, c]
    end.check(5, 200) do |a, b, c|
      a.should <= c
    end

    # Existence of a Least Element
    specify "∅ ⊆ A" do
      null.should <= null
      null.should <= single
      null.should <= subset
      null.should <= universe
    end

    # Existence of a Greatest Element
    specify "A ⊆ U" do
      null.should <= universe
      single.should <= universe
      subset.should <= universe
      universe.should <= universe
    end

    # Existence of Joins
    property("A ⊆ A ∪ B") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      a.should <= (a | b)
    end

    # Existence of meets
    property("A ∪ B ⊇ C, given C ⊆ A and C ⊆ B") do
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))

      a = mksubset(universe)
      b = mksubset(universe)
      c = mksubset(universe)
      guard(c <= a)
      guard(c <= b)

      [a, b, c]
    end.check(5, 200) do |a, b, c|
      (a | b).should >= c
    end

    # Equivalent Statements
    property("A ⊆ B => ...") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      if a <= b
        (a & b).should == a
        (a | b).should == b
        (a - b).should == null
        (~b).should <= (~a)
      end
    end

    # Equivalent Statements
    property("A ∩ B = A => ...") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      if (a & b) == a
        a.should <= b
        (a | b).should == b
        (a - b).should == null
        (~b).should <= (~a)
      end
    end

    # Equivalent Statements
    property("A ∪ B = B => ...") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      if (a | b) == b
        a.should <= b
        (a & b).should == a
        (a - b).should == null
        (~b).should <= (~a)
      end
    end

    # Equivalent Statements
    property("A ∖ B = ∅ => ...") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      if (a - b) == null
        a.should <= b
        (a & b).should == a
        (a | b).should == b
        (~b).should <= (~a)
      end
    end

    # Equivalent Statements
    property("¬B ⊆ ¬A => ...") do
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      if (~b) <= (~a)
        a.should <= b
        (a & b).should == a
        (a | b).should == b
        (a - b).should == null
      end
    end

    context "if B is a RelativeSet" do
      context "and B ⊆ U" do
        property("then A ⊆ B = A ⊆ Sets.absolute(B, U)") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, b|
          r = Stupidedi::Sets.build(b.to_a)
          (a <= b).should == (a <= r)
        end
      end

      context "and B ⊈ U" do
        property("then A ⊈ B = A ⊆ Sets.absolute(B ∩ U, U)") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))
          [a, b]
        end.check do |a, b|
          r = Stupidedi::Sets.build(b.to_a)       # B
          b = universe.select{|x| b.include?(x) } # B ∩ U
          (a <= b).should == (a <= r)
        end
      end
    end

    context "if B is a RelativeComplement(C)" do
      context "and C ⊆ U" do
        property("then A ⊆ ¬C ≡ A ∩ C = ∅") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, c|
          b = Stupidedi::Sets.complement(c.to_a)
          (a <= b).should == ((a & c) == null)
        end
      end

      context "and C ⊈ U" do
        property("then A ⊆ ¬C ≡ A ∩ C = ∅") do
          a = mksubset(universe)
          c = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))
          [a, c]
        end.check do |a, c|
          b = Stupidedi::Sets.complement(c.to_a)
          (a <= b).should == ((a & c) == null)
        end
      end
    end

    context "when B is an Array" do
      context "and B ⊆ U" do
        property("then A ⊆ B = A ⊆ Sets.absolute(B, U)") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, b|
          r = b.to_a
          (a <= b).should == (a <= r)
        end
      end

      context "and B ⊈ U" do
        property("then A ⊆ B = A ⊆ Sets.absolute(B ∩ U, U)") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))
          [a, b]
        end.check do |a, b|
          r = b.to_a                              # B
          b = universe.select{|x| b.include?(x) } # B ∩ U

          (a <= b).should == (a <= r)
        end
      end
    end
  end

  describe "#==(other)" do
    # Reflexive
    specify "A = A" do
      null.should == null
      single.should == single
      subset.should == subset
      universe.should == universe
    end

    # Symmetric
    property("if A = B then B = A") do
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))
      [mksubset(universe), mksubset(universe)]
    end.check do |a, b|
      if a == b
        b.should == a
      end
    end

    # Transitive
    property("if A = B and B = C then A = C") do
      universe = Stupidedi::Sets.absolute(%w(a b c d e f))
      [mksubset(universe), mksubset(universe), mksubset(universe)]
    end.check do |a, b, c|
      if a == b and b == c
        a.should == c
      end
    end

    context "if B is a RelativeSet" do
      context "and B ⊆ U" do
        property("then A = B ≡ A = Sets.absolute(B, U)") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, b|
          r = Stupidedi::Sets.build(b.to_a)
          (a == b).should == (a == r)
        end
      end

      context "and B ⊈ U" do
        property("then A = B ≡ A = Sets.absolute(B ∩ U, U)") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))
          [a, b]
        end.check do |a, b|
          r = Stupidedi::Sets.build(b.to_a)       # B
          b = universe.select{|x| b.include?(x) } # B ∩ U
          (a == b).should == (a == r)
        end
      end
    end

    context "if B is a RelativeComplement" do
      context "and ¬B ⊆ U" do
        property("then A = B ≡ B = A") do
          a = mksubset(universe)
          b = mksubset(universe)

          [a, Stupidedi::Sets.complement(b.to_a)]
        end.check do |a, b|
          (a == b).should == (b == a)
        end
      end

      context "and ¬B ⊈ U" do
        property("then A = B ≡ B = A") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))

          [a, Stupidedi::Sets.complement(b.to_a)]
        end.check do |a, b|
          (a == b).should == (b == a)
        end
      end
    end

    context "if B is an Array" do
      context "and B ⊆ U" do
        property("then A = B ≡ A = Sets.absolute(B, U)") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, b|
          r = b.to_a
          (a == b).should == (a == r)
        end
      end

      context "and B ⊈ U" do
        property("then A = B ≡ A = Sets.absolute(B ∩ U, U)") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))
          [a, b]
        end.check do |a, b|
          r = b.to_a                              # B
          b = universe.select{|x| b.include?(x) } # B ∩ U

          (a == b).should == (a == r)
        end
      end
    end
  end

  describe "#replace(other)" do
    context "if B is an AbsoluteSet" do
      context "and B.universe = U" do
        property("then A.replace(B) = B") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, b|
          a.replace(b).should == b
        end
      end

      context "and B.universe ≠ U" do
        property("then A.replace(B) = B") do
          a = mksubset(universe)
          b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                                universe.to_a.map(&:upcase)))
          [a, b]
        end.check do |a, b|
          a.replace(b).should == b
        end
      end
    end

    context "if B is a RelativeSet" do
      property("then A.replace(B) = B") do
        a = mksubset(universe)
        b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                              universe.to_a.map(&:upcase)))
        [a, Stupidedi::Sets.build(b.to_a)]
      end.check do |a, b|
        a.replace(b).should == b
      end
    end

    context "if B is a RelativeComplement" do
      property("then A.replace(B) = B") do
        a = mksubset(universe)
        b = mksubset(Stupidedi::Sets.absolute(universe.to_a +
                                              universe.to_a.map(&:upcase)))
        [a, Stupidedi::Sets.complement(b.to_a)]
      end.check do |a, b|
        a.replace(b).should == b
      end
    end

    context "if B is an Array" do
      context "and B ⊆ U" do
        property("then A.replace(B) ≡ Sets.absolute(B, U)") do
          [mksubset(universe), mksubset(universe)]
        end.check do |a, b|
          a.replace(b.to_a).should == b
        end
      end

      context "and B ⊈ U" do
        property("then A.replace(B) raises an error") do
          a = mksubset(universe)
          b = mksubset(universe)
          c = mksubset(universe)
          guard(!c.empty?)

          [a, (b.to_a | c.to_a.map(&:upcase))]
        end.check do |a, b|
          lambda { a.replace(b) }.should \
            raise_error(/invalid character/)
        end
      end
    end
  end

end
